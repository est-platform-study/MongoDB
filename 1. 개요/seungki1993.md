### 개요

- MongoDB는 웹 애플리케이션과 인터넷 기반을 위해 설계된 데이터 베이스
  - 데이터 모델과 지속성 전략은 높은 읽기 / 쓰기 효율과 장애조치를 통한 확장의 용이
  - 관계형 데이터 베이스와 다르게 Document 형식으로 저장
    - Document는 key와 value를 가진 데이터의 집합이라고 볼 수 있다.
  - 관계형 데이터 베이스와 다르게 복잡한 연산이 필요하지 않다 .
    - 예를 들면 유저의 모든 정보를 가져오기 위해서는 관계형 데이터 베이스는 때로 조인이 필요로 하다.
    - MongoDB는 document 방식의 저장 store 이기 때문에 하나의 Document로 유정의 모든 정보를 표현 할 수 있다.
  - 매퍼의 복잡성이 사라진다.
    - 관계형 데이터 베이스에서는 객체를 저장하기 위해서 각 컬럼의 객체의 속성을 매핑 시켜서 저장하고 가져오는 반면에 MongoDB는 객체를 그 대로 저장한다. 



- MongoDB는 BSON의 형태로 Document를 저장한다.
  - BSON은 JSON문서를 바이너리로 인코딩한 포멧이다.
  - 최대 사이즈는 16 megabytes
  - 모든 도큐먼트는 프라이머리 키가 있고 생갹하면 몽고에서 자동으로 추가한다.



- BSON형식의 Document는 collection에 저장된다.
  - 쉽게 생각하면 Collection은 관계형 데이터 베이스의 테이블과 유사하다
  - MongoDB는 스키마가 없기 때문에 하나의 콜랙션에 들어있는 document의 형식은 다 다를 수 있다.
    - But 보통은 컬랙션 내에 Docuemt는 상대적으로 동일한 구조를 갖도록 한다.



- 스키마 없는 모델의 장점
  - 데이터 베이스가 아닌 애플리케이션이 데이터 구조를 정한다는 것이다.
    - 데이터 베이스에 경우 먼저 스키마를 정의하고 애플리케이션에서 스키마에 맞게 데이터를 형식을 맞추는 반면 스키마 없는 모델은 애플리케이션에 데이터가 그대로 DB에 저장이 되기 때문에 애플리 케이션이 데이터 구조를 정한다고 이야기 한다.
  - 가변 적인 속성을 갖는 데이터를 표현 할 수 있다.



- MongoDB에서도 index를 지원한다.
  - 인덱스의 자료 구조는 B tree로 되어 있다.
  - 관계형 데이터 베이스 처럼 primary key index 부터 secondary index 까지 지원한다.
  - 한 컬렉션에 64개 까지 secondary index를 만들 수 있다.



- MongoDB는 복제 세트라고 부르는 구성을 통해 복제(replica)를 지원한다.
  - 복제 세트는 많은 MongoDB서버로 구성되어 있다.
    - MongoDB서버는 각각의 서버에 존재하며 이를 노드라고한다.
    - elasticsearch의 노드와 유사한 개념
    - 한서버에서도 구축이 가능하나 이를 권장 x
  - 복제세트는 하나의 프라이머리  + 하나 또는 그 이상의 세컨더리가 존재
  - 마스터 슬레이브 구조와 유사
    - 프라이머리는 읽기 / 쓰기 모두가능
    - 세컨더리는 읽기만 가능(프라이 머리에 복제)
  - 복제세트는 장애조치를 자동으로 지원한다.
    - 프라이머리가 고장나면 세컨더리 중 하나를 프라이머리로 만들어버린다.
    - 그 후 프라이머리가 복구가 되면 프라이머리는 세컨더리로 변해 수행한다.



- MongoDB 속도와 내구성
  - 속도는 쓰기 속도를 의미
  - 내구성은 쓰기 연산이 디스크에 제대로 반영이 되었는지
  - 해당 책에서는 최고의 속도와 최고의 내구성은 같이가겨져 갈 수 없으니 포기 할것은 과감하게 포기해야한다.
  - 즉 속도와 내구성 사의의 타협이 필요한데 MongoDB는 저널링, 쓰기 시맨티스로 한다.
    - 저널링 
      - 서버에 이상 상황이 발생할 것을 대비하여 저널 파일을 만들어서 무결성을 확보하는 것
      - elasticsearch 트랜스 로그라고 생각하면 된다.
    - 쓰기 시맨티스 -> write concern 같다... document 상에서
      - 즉 client에 요청에 대한 응답을 언제주는지
      - 기본적으로 요청이 오면 primary에 기록하고 response를 보낸다. 그 후 primary는 secondary에 데이터 동기화를 한다. 그런데 만약 동기화 되는 과정 중에 primary가 고장이 나면 동기화를 하지 못하고 primary가 되기에 데이터 불일치가 발생
        - 그렇기에 옵션을 주어 client에 응답을 보내는 타이밍을 설정 할 수 있다.



- 확장
  - 수직 확장 수평확장
    - 수직 확장은 서버 업그레이드
    - 수평 확장은 여러대 서버에 mongodb 서버를 분산하는것
  - 몽고디비는 수평확장의 용이하다
    - 샤딩을 통해 여러노드에 데이터를 분산하는 것을 자동으로 관리 해준다
    - 샤딩에는 hash , tag 기반 샤딩(3.4버전에서 tag가 zone으로 바뀜)
  - 샤드 복제 세트로 이루어져 있다.



- 코어 데이터 베이스 서버는 mogod 
  - mongod 실행하면 몽고 서버 실행
  - 즉 엘라스틱 서치 실행하는거 와 같고 마찬가지로 mongod에서 저장되는 데이터는 같은 서버에 저장



- mongos 별도의 라우팅 서버

  - 샤드로 서비스 요청을 보내는 역할

  

- 상용에서 구동 할때는 복제가 권장 사항이며 두개의 복제 노드와 아비터 모드로 구동하는 복제 세트가 일반적이다.

  - 아비터 모드
    - 프라이머리가 죽어 세컨더리를 프라이 머리로 만들어야 하는데 이때 투표에만 참여하는 것을 아비터라고 한다.



- 데이터 베이스 드라이버



- 다양한 커맨드라인툴 존제
  - mongodump , mongostore 백업과 복구
  - mongoexport , mongoimport 데이터 임폴틀 엑스포트
  - mongostat 연산된 수나 할당된 가상 메모리양 , 서버에 대한 연결의 수와 같이 통계 데이터 제공
  - mongotop 각 컬렉션의 데이터를 읽고 쓰는데 걸린 시간의 양



- mongoDB의 적합도
  - 웹 애플리케이션 , 분석과 로깅 애플리케이션 중간 정도의 캐시를 필요로 하는 애플리케이션에서 일차 데이터 저장 시스템으로 적합하다.
  - 스키마가 없기 때문에 구조가 미리 알려지지 않은 데이터를 저장하는데 유용하다
  - 분석과 로깅
    - 분석에 적합한 것은 속도가 빠르다
    - 단일 document에 대한업데이트에 대한 원자성 
      - 다중 document 업데이트에는 원자성 지원 x
    - 캡드 컬랙션(로깅)
      - 고정 된 크기를 가진 컬랙션
      - 오랜된거에 덮어쓰는 형식 항상 최신 유지
  - 캐싱



- 다양한 디비와의 비교
  - 간단한 키 - 값 저장 시스템
    - 멤케시디 (인메모리 DB)
    - 데이터 지속성을 포기했기 때문에 속도측면에서는 빠르다
    - MongoDB와 다르게 저장 시스템으로 사용하지 않는다.
  - 정교한 키값 저장시스템
    - 예 아마존의 다이나모
    - MongoDB와 다르게 마스터 노드가 없으며 모든 노드가 동등하게 수행한다
    - 궁극적인 일관성을 채택
      - 현재 읽은 데이터가 반드시 가장 마지막에 쓰여진 데이터는 아니다
    - MongoDB는 엄격한 일관성과 다양한 데이터 모델 , 센컨더리 인덱스를 제공한다.
  - 관계형 데이터 베이스
    - 공통점
      - 다양한 데이터 모델링 가능
    - 관계형 데이터 베이스보다 빠르게 개발이 가능하다
      - 지정된 스키마가 없기 때문에 시간 절약을 할 수 있다.
  - CouchDB
    - MongoDB는 BSON 으로 저장하는 반면에 CouchDB는 JSON형식으로 저장
    - CouchDB는 복제본이 한 노드에 있다. elasticsearch의 replica처럼 하나의 서버에 복제본이 있다는 뜻이다.



- MongoDB 단점
  - 메모리 맵 기법에 의해 데이터 처리
    - 파일의 일부 영역을 가상 메모리 일부에 연결 시키는 메커니즘
    - 데이터를 파일과 연결되 있는 가상 메모리 영역에 저장하면 메모리에만 데이터가 저장이 되는것이 아니라 파일에도 저장된다.  또한 파일에 저장된 데이터를 조작하기 위해서는 데이터를 메모리로 읽어들이고 조작 후 에 파일에 다시 저장하는 방식이아닌 메모리 상의 저장된 데이터를 조작하면 파로 파일에 저장이 된다.
  - 64비트에서 실행되어야한다.
    - 32bit는 최대 4GB메모리만 사용하기에 MongoDB가 더이상 데이터를 저장하지 못한다.
  - mongodb가 필요한 경우 메모리를 자동으로 할당한다
    - 즉 메모리 크기에 큰 영향을 받는다.
  - 쿼리가 sql만큼 친숙하지 않다.
  - 대규모 클러스터 운용시 큰 유지비용이 들 수 있다.



- mongodb store engine
  - MMAPV1 store engine
    - memory mapped files 기반 
    - 몽고디비 4.0때 deprecate 에정
    - collection 레벨 락킹
  - WiredTiger storage Engine
    - 3.2 부터 default
    - document레벨 락킹
    - 저널링 기능을 제공하지 않는다. 
    - 저널링 대신 checkpoints라는 개념을 사용


- 몽고디비 디폴트 port 27017











